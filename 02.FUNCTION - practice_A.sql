
--------------------------- 함수(FUNCTION)------------------------------

/*
22.03.14

함수(FUNCTION)

함수 두 종류
1.단일 행 함수
2.그룹 함수


 1.단일 행 함수
n개의 데이터를 넣으면 n개가 나오는 것
n개의 값을 읽어서 n개의 결과 리턴

2.그룹 함수
n개의 데이터를 넣으면 1개 나오는 것
n개의 값을 읽어 1개의 결과 리턴


SELECT절에 단일 행 함수와 그룹 함수를 함께 사용할 수 있다/없다?
A. 없다

WHY?
result set의 결과는 테이블이었다
단일행 쓰면 여러 결과가 나오는데 그룹은 하나의 테이블이 나온다
같이 쓰면 테이블 하나가 제대로 안나오게 됨

-- SELECT절에 단일 행 함수와 그룹함수를 함께 사용할 수 없다
결과 행의 개수가 다르기 때문


함수를 사용할 수 있는 위치
SELECT 절
WHERE 절
GROUP BY 절
HAVING 절
ORDER BY 절
( 사실상 프론트빼고 다 가능)

1.단일 행 함수
자바 메소드랑 비슷
 1)문자 관련 함수
LENGTH / LENGTHB

2)


2.그룹 함수
 
 
 
 
*/
------------------------------------------------------------------------------
------------------------------------------------------------------------------
------------------------------------------------------------------------------
-- 1.단일 행 함수
-- 1)문자 관련 함수
-- LENGTH / LENGTHB
-- B = BYTE
-- LENGTH  : 길이
-- LENGTHB : 글자의 바이트 사이즈 반환 
--      한글 : 3 byte
--      영어, 숫자, 특수기호 : 1 byte



SELECT LENGTH('오라클'), LENGTH('ORACLE') FROM EMPLOYEE; -- 3 6
SELECT LENGTHB('오라클'), LENGTHB('ORACLE') FROM EMPLOYEE; -- 9 6
SELECT LENGTH(EMAIL), LENGTH(EMAIL) FROM EMPLOYEE;
SELECT LENGTHB(EMAIL),
-- 리터럴값도 가능하지만 컬럼도 가능

SELECT LENGTH(EMAIL), LENGTH(EMAIL) FROM EMPLOYEE;
-- 이름, 이메일 -> 길이, 바이트 사이즈

SELECT LENGTH(EMP_NAME),LENGTHB(EMP_NAME) FROM EMPLOYEE; -- 3 9
SELECT LENGTH(EMP_NAME), LENGTH(EMAIL) FROM EMPLOYEE; -- 길이 3 15
SELECT EMP_NAME, LENGTHB(EMP_NAME), LENGTHB(EMAIL) FROM EMPLOYEE; -- 길이B 9 15
        
SELECT EMP_NAME, LENGTH(EMP_NAME), LENGTHB(EMP_NAME),
        EMAIL, LENGTH(EMAIL), LENGTHB(EMAIL)
FROM EMPLOYEE; -- 선동일	3	9	sun_di@kh.or.kr	15	15


------------------------------------------------------------------------------
------------------------------------------------------------------------------


--  INSTR
-- 해당 문자열이 처음 나온 위치 인덱스번호 반환(ZERO-INDEX X)
-- INSTR(’문자열’or컬럼명, ‘찾아낼 문자‘,  시작 index, 2번째인자인 문자가 몇번째 나오는 문자인지)

--1번째 인자 : 찾을 문자열 or 컬럼명. 
--2번째 인자 : 첫번째 중에 찾고 싶은 문자
--3번째 인자 : 몇번째부터 읽기 시작할 것이냐. 안적으면 1부터 시작
--4번째 인자 : ' '의 문자가 세번째인자로부터 세기 시작해서 "몇번째로 나오는 문자인가”
--    1,2번째 인자는 리터럴( ‘ ‘ )로 감싼다
 
-- 없는 문자열은 0반환 // 만약, 제로인덱스였다면 -1반환
-- AABAACAABBAA
SELECT INSTR('AABAACAABBAA','A') FROM EMPLOYEE; --1
SELECT INSTR('AABAACAABBAA','B') FROM EMPLOYEE; --3
SELECT INSTR('AABAACAABBAA','C') FROM EMPLOYEE; --6
SELECT INSTR('AABAACAABBAA','D') FROM EMPLOYEE; -- 0 // 없는 수는 0을 반환
SELECT INSTR('AABAACAABBAA', 'AB') FROM EMPLOYEE; -- 2
SELECT INSTR('AABAACAABBAA', 'AB',3) FROM EMPLOYEE; -- 8
-- 두글자 이상은 첫글자 기준으로 인덱스반환

SELECT INSTR('AABAACAABBAA','B',7) FROM EMPLOYEE; -- 9
SELECT INSTR('AABAACAABBAA','B',7,1) FROM EMPLOYEE; -- 9
-- 코딩해설 : 7번쨰부터 읽기 시작해서 B가 처음 나올 때까지 읽어서, 처음 나오는 B의 위치 반환해

-- 마이너스(-)는 거꾸로 읽기
-- 역순 뒤에서 찍은 기준점 기준으로 왼쪽으로 세기
SELECT INSTR('AABAACAABBAA','B',-10) FROM DUAL; -- 3
SELECT INSTR('AABAACAABBAA','B',-10,1) FROM DUAL; -- 3
SELECT INSTR('AABAACAABBAA','B',-1,2) FROM DUAL; -- 9
SELECT INSTR('AABAACAABBAA','B',-1,3) FROM DUAL; -- 3
SELECT INSTR('AABAACAABBAA','A',-2,5) FROM DUAL; -- 5
SELECT INSTR('AABAACAABBAA','A',1,4) FROM DUAL; -- 5

-- 1에서부터 두번째 있는 'B'를 찾아라
SELECT INSTR('AABAACAABBAA','B',1,2) FROM DUAL; -- 9

-- EMPLOYEE테이블에서 이메일의 @위치 반환
SELECT INSTR(EMAIL,'@',1) FROM EMPLOYEE; -- 7 
SELECT EMAIL, INSTR(EMAIL,'@') FROM EMPLOYEE; -- sun_di@kh.or.kr 7


------------------------------------------------------------------------------
------------------------------------------------------------------------------


-- LPAD / RPAD
-- 왼쪽 공백 / 오른쪽 공백
-- 오른쪽 정렬 / 왼쪽 정렬
-- 주어진 값에 임의의 문자열을 왼쪽/오른쪽에 덧붙여 길이 n개의 문자열 반환
-- LPAD(컬럼명, 문자 총 길이,공백 대신 대체할 문자)
-- 전체 길이에서 남은 공간에 공백으로 채움


--      sun_di@kh.or.kr// 세팅 :20
SELECT LPAD(EMAIL,20) FROM EMPLOYEE; --      sun_di@kh.or.kr
-- sun_di@kh.or.kr     //
SELECT RPAD(EMAIL, 20) FROM EMPLOYEE;


-- 값보다 지정한 총길이가 짧으면 뒤부터 짤림
SELECT LPAD(EMAIL, 12) FROM EMPLOYEE; -- sun_di@kh.or
-- 공백대신 대체할 문자 삽입
SELECT LPAD(EMAIL, 20, '^') FROM EMPLOYEE;


SELECT RPAD(EMAIL,20,'_'), LPAD(EMAIL,20,'_') FROM EMPLOYEE;
SELECT LPAD(EMAIL,20,'_'), RPAD(EMAIL,20,'_') FROM EMPLOYEE;


------------------------------------------------------------------------------
------------------------------------------------------------------------------

-- LTRIM / RTRIM
-- 좌/우에서부터 지정한 문자를 제거한 나머지 반환
--      문자를 지정하지 않을 경우, 공백 제거
-- LTRIM : 왼쪽부터 순서대로 제거
-- RTRIM : 오른쪽부터 순서대로 제거
-- 지울려는 문자가 아닌 문자에 다다르면 TRIM 중지

-- 자바 STRING클래스에서 TRIM은 공백제거 메소드

--    KH//KH//
SELECT LTRIM('   KH') FROM DUAL;
--    KH//   KH// 
SELECT RTRIM('   KH') FROM DUAL;

-- 000123456
-- 0만 제거하고 나머지를 반환
SELECT LTRIM('000123456','0') FROM DUAL; -- 123456

-- 0001230456
-- 중간에 껴있는 해당 문자는 제거X
SELECT LTRIM('0001230456','0') FROM DUAL; -- 1230456


-- ACABACCKH // KH
SELECT LTRIM('ACABACCKH','ABC') FROM DUAL; -- KH
-- 'ABC' 묶여진 문자 하나로 보는게 아니라, A 또는 B 또는 C가 있으면 다 지우는 것
-- 'ABC' 안에 순서 상관X
SELECT RTRIM('ACABACCKH','CBA') FROM DUAL; -- ACABACCKH // -- 지울려는 문자가 아닌 문자에 다다르면 TRIM 중지
SELECT RTRIM('ACABACCKH','ABC') FROM DUAL; -- ACABACCKH 
SELECT LTRIM('ACABACCKH','CBA') FROM DUAL; -- KH

-- KH   // KH
-- 오른쪽부터 공백제거
SELECT RTRIM('KH    ') FROM DUAL; -- KH

-- 01230456000 // 01230456
SELECT RTRIM('01230456000','0') FROM DUAL; -- 01230456
-- KHACABACC // KH
SELECT RTRIM('KHACABACC','ABC') FROM DUAL; -- KH
-- 오른쪽부터 지우기 시작



------------------------------------------------------------------------------
------------------------------------------------------------------------------


-- TRIM
-- 앞/뒤/양쪽에서 지정한 문자를 제거한 나머지 반환
-- TRIM(제거방향, '제거할 문자 1개', '찾을 문자열OR컬럼명')
-- LEADING : 앞부터 제거
-- TRAILING : 뒤부터 제거
-- BOTH : 양쪽에서부터 제거

--    KH   // KH // A는 별칭
SELECT TRIM('    KH   ') A FROM DUAL; -- KH
--'ZZZKHZZZ' // KH
SELECT TRIM('Z' FROM 'ZZZKHZZZ') FROM DUAL; -- KH


-- ZZZKHZZZ // KH
SELECT TRIM('Z' FROM 'ZZZKHZZZ') FROM DUAL;
-- 123KH3123123 // error : trim set should have only one character
SELECT TRIM('ZZ' FROM 'ZZZKHZZZ') FROM DUAL;
-- TRIM은 제거할 문자 1개만 받는다

-- ZZZKHZZZZ // KHZZZZ
-- LEADING 앞부터 제거
SELECT TRIM(LEADING 'Z' FROM 'ZZZKHZZZZ') FROM DUAL; -- KHZZZZ

-- ZZZKHZZZZ // ZZZKH
-- TRAILING 뒤부터 제거
SELECT TRIM(TRAILING, 'Z' FROM 'ZZZKHZZZZ') FROM DUAL;


-- ZZZKHZZZZ //KH
-- BOTH 양쪽에서부터 제거


--LTRIM/RTRIM처럼 인자 추가 형식이 아닌 
--코드 구조를 바꿔서 써야함 
--제거를 지우겠다 어디서부터? 컬럼명부터


------------------------------------------------------------------------------
------------------------------------------------------------------------------

--SUBSTR
-- String.substring()
--SUBSTR(컬럼명, 시작위치 인덱스, 시작위치부터 값을 반환할 길이)

-- HELLOMYGOODFRIENDS // YGOODFRIENDS
-- 7번째서부터 끝까지 반환

-- HELLOMYGOODFRINEDS // OM
-- 5번째 문자부터 2개만 반환

-- HELLOMYGOODFRINEDS // (null)
-- 5번쨰 문자부터 0개 반환 // 0개 반환이 불가능하기에 NULL 출력됨

-- HELLOMYGOODFRINEDS // HELLOM

-- HELLOMYGOODFRINEDS //  DFR
-- 뒤에서 8번째(D)부터 오른쪽으로 3개의 문자 반환
-- 위에서 마이너스(-)였으면 기준점이 뒤에서부터 세고 왼쪽방향으로 카운팅했지만 얘는 오른쪽으로 카운팅

-- HELLOMYGOODFRINEDS // OO


-- EMPLOYEE 테이블에서 이름, 이메일, 이메일의 아이디 조회
-- (이메일의 @ 도메인말고 아이디까지만)

-- 문제풀이 사고과정
-- 1.이메일 아이디의 규칙은 항상 @이 앞에 있음
-- 2. @ 위치 파악
-- 3. 1~@앞까지 찾기




-- 주민등록번호를 이용하여 이름과 성별을 나타내는 부분 조회
-- EMPLOYEE 테이블에서 남자만 조회(사원명, '남')
-- EMPLOYEE 테이블에서 여자만 조회(사원명, '여')


-- 추가공부
--SELECT EMP_NO, SUBSTR(EMP_NO, 7, INSTR(EMP_NO, '-')+1) FROM EMPLOYEE;
-- SUBSTR & INSTR 사용해서 할 수 있는 방법이 없을까?



-- EMPLOYEE테이블에서 직원들의 주민번호를 이용하여 사원명, 생년, 생월, 생일 조회




------------------------------------------------------------------------------
------------------------------------------------------------------------------


-- LOWER / UPPER / INITCAP
-- INITCAP :각 단어의 첫글자만 대문자

-- 예제 Welcome To my World
-- welcome to my world
-- WELCOME TO MY WORLD
-- Welcome To My World



------------------------------------------------------------------------------
------------------------------------------------------------------------------

-- CONCAT
-- 문자열 이어붙이기

-- 가나다라123

-- 연결연산자 사용 : 가나다라123
-- 연결연산자 : ||

-- 컬럼명끼리 붙이면 어찌될까?


------------------------------------------------------------------------------
------------------------------------------------------------------------------

-- REPLACE
-- REPLACE(컬럼명,바꿔질 단어, 바꿀 단어)
-- 값 교체

-- 서울시 강남구 역삼동 // 서울시 강남구 삼성동

-- 강사님은 오라클을 수업중이다 // 선생님은 오라클을 수업중이다
-- 띄어쓰기 상관없이 적용가능


-- 케이크 달다. 케이크 싫은사람? // 공부 달다. 공부 싫은사람?
-- 여러개 들어있어도 복수로 교체가능. 일치만 하면 전부 교체함


-- EMPLOYEE테이블에서 사원명, 주민번호 조회
-- 주민번호의 뒷자리는 *로 바꿔서 조회(EX.001122-*******)


-- 방법1
-- REPLACE+SUBSTR 끝수 지정 & 미지정 


-- 방법2
-- RPAD+SUBSTR
SELECT EMP_NAME, RPAD(SUBSTR(EMP_NO,1,7),14,'*')
FROM EMPLOYEE;

-- RPAD+SUBSTR+INSTR


-- RPAD+SUBSTR+INSTR+LENGTH


-- 방법3
-- REPLACE+SUBSTR+INSTR+LENGTH


-- 방법4
-- SUBSTR+연결연산자(||)
SELECT EMP_NAME, SUBSTR(EMP_NO, 1, 7) || '*******' 주민번호
FROM EMPLOYEE;

-- 방법5
-- LPAD+연결연산자(||)

-- LPAD가 원래 앞에를 가져오는 용도는 아니니 주의


-- 방법6
-- CONCAT+SUBSTR




------------------------------------------------------------------------------
------------------------------------------------------------------------------
------------------------------------------------------------------------------
------------------------------------------------------------------------------

-- 2) 숫자 관련 함수


-- ABS
-- 절대값 반환

-- 10.9	10.9	10	10
-- 전부 양수 출력


-- MOD
-- 모듈러
-- 나머지 구하기
-- MOD(나눠지는수 ,나누는 수)

-- 1	-1	1	-1	1.9
-- 내가 나누어지는 수에 대한 부호를 따라가게 됨



-- ROUND
-- 몇번째 자리에서 반올림할지 소수점 자리수 지정가능
-- 123	124	123	123.5	123.46	120	100
-- 소수점 자리지정 반올림
-- 소수점 -의 반올림


-- -11
-- 마이너스(-)의 반올림은?
-- 마이너스는 숫자가 클수록 작은 수 ex) -11이 -10보다 작은 수
-- -10.61에서 .61이 5이상이라 반올림이 되는데 -11로



-- CEIL
-- 124
-- 무조건 1의 자리에서 올림하게 되어있음
-- 자릿수 지정 불가. 다른 인자값 집어넣으면 에러



-- FLOOR / TRUNC
-- FLOOR : 수학적 내림(배웠던 수학의 내림)
-- TRUNC : 버림. 절삭. 몇번째 자리까지 버리겠다 자릿수 지정가능

-- 123	123	123.7
-- TRUNC : 몇번째 자리까지 버리겠다 자릿수 지정가능
-- 파이썬에서 FLOOR가 -쪽으로 내리고 TRUNC가 0쪽으로 수렴하는 것과 같은 개념
-- math.trunc(-3.14)   #결과는 -3
-- math.floor(-3.14)   #결과는 -4






------------------------------------------------------------------------------
------------------------------------------------------------------------------
------------------------------------------------------------------------------
------------------------------------------------------------------------------





-- 3)날짜 관련 함수

-- SYSDATE
-- 시스템에 저장되어있는 시간을 사용

-- 22/03/14



-- MONTHS_BETWEEN
-- 개월수의 차를 숫자로 리턴해주는 함수

-- EMPLOYEE테이블에서 사원의 이름, 입사일, 근무 개월 수 조회
-- 385.283...
-- ABS 이용 같은코드
-- 368개월차
-- SYSDATE의 날짜에서 HIRE_DATE를 뺀 것 : SYSDATE - HIRE_DATE


-- CEIL+ABS+MONTHS_BETWEEN
-- 368개월차
-- 앞뒤로 뭐가 올지 모른다면 ABS를 넣어서 절대값으로 받아오면 된다


-- ADD_MONTHS
-- 기준 날짜에다 지정한 숫자만큼의 개월수로 더한 날짜 리턴
-- 22/07/14
-- 지금부터 4개월 뒤 반환됨

-- 23/01/14
-- 개월수가 더해져서 연도가 넘어가면 연도도 올라감


--EMPLOYEE테이블에서 사원의 이름, 입사일, 입사 후 6개월이 된 날짜 조회



------------------------------------------------------------------------------
------------------------------------------------------------------------------
------------------------------------------------------------------------------
















------------------------------------------------------------------------------
------------------------------------------------------------------------------
------------------------------------------------------------------------------








------------------------------------------------------------------------------
------------------------------------------------------------------------------
------------------------------------------------------------------------------















------------------------------------------------------------------------------
------------------------------------------------------------------------------
------------------------------------------------------------------------------








------------------------------------------------------------------------------
------------------------------------------------------------------------------
------------------------------------------------------------------------------



















------------------------------------------------------------------------------
------------------------------------------------------------------------------
------------------------------------------------------------------------------








------------------------------------------------------------------------------
------------------------------------------------------------------------------
------------------------------------------------------------------------------



